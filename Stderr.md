Streams in wit are special. They allow for async I/O and error handling. However, these aren't relevant for typical uses of stderr. The way most programs use stderr, it's a simple synchronous infallible sink for line-oriented messages. And by designing an API around that kind of use case, we can more easily run wasm programs in non-traditional environments; it'll be friendlier to browsers, serverless platforms, and many embedded use cases.

## Component-level API:

```wit
enum level {
    trace,
    debug,
    info,
    warning,
    error,
}

log: func(level: level, context: string, message: string)
```

## Core-wasm API:

The Canonical ABI bindings for the Component ABI as generated by wit-bindgen.

## What is the context string?

The string may be "stderr" to desginate the conceptual stderr stream that many programming models expect to have.

Or it may be some other convention. TODO: Describe the convention.

## What about newlines?

Log messages are expected to be single-line messages without including a trailing newline. This means that POSIX-like toolchains may need to buffer stderr to be able to print complete lines.

## What about progress bars and other displays?

Popular progress bars like [indicatif](https://docs.rs/indicatif/latest/indicatif/) draw to stderr. They also need to query the number of columns and will often use color escape sequences. However, this all requires control characters which not all environments will support in the same way. And not all environments will have a fixed number of columns or will want to share the number with untrusted code. So the rough plan is to say that in the future, we could have an "advanced stderr" feature, but for now, we're keeping it simple.

## What about using `dup2` to overwrite stderr with a different destination?

That can be emulated in libc.
