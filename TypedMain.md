# The Levels of Typed Main

For some background on Typed Main, see [this presentation] which was given to the
WASI Subgroup. Some of the details are out of date, but the overall idea holds.

[this presentation]: https://sunfishcode.github.io/typed-main-wasi-presentation/

Typed Main applies to entities with *command* lifetime.

Typed Main can be introduced in phases:

 - Level 0: The developer writes a program that has an untyped main, aka
   `int main(int argc, char *argv[])` or various variations. At link time, the
   developer specifies a list of environment variables their program will need.
   This requires the fewest toolchain changes, but interoperation with other
   components is limited.

 - Level 1: Like Level 0, but the developer now writes a wit file describing a
   typed `main` signature. We'd build a tool that takes this wit and a core-wasm
   executable, and generates a command component. This allows interoperating with
   the component ecosystem without significant toolchain changes.

 - Level 2: Source language toolchains have support for Typed Main built in and
   the user uses them directly. This requires more changes on the part of toolchains
   and developers, but offers the best interoperation with other components.

In the Preview2 timeframe, we'll just do Level 0.

## Level 0

### Developer or low-level toolchain interface:

The developer or toolchain defines a traditional C-style `argv`-style `main`
function, and optionally also traditional C++/attribute((constructor))-style
static initializers collected by the linker into a synthesized
`__wasm_call_ctors` function.

Developers or toolchains must also statically identify the set of environment
variables that programs are expected to read. This might either be within the
source code, or flags passed to the linker.

### Component ABI

A *command* (component) takes its "arguments" as explicit value imports:
```wit
stdin: stream<u8, expected<_, _>>
args: list<string>
preopens: list<(string, handle preopen)>
```
and returns its "result" as an explicit value export:
```wit
stdout: stream<u8, expected<_, _>>
```
TODO: In theory this should be a 0-level export; how do we express that in wit?

For each declared environment variable, there will be an import added like this:
```wit
  (import "key" (default "wasi:env") (value string))
```
where "key" is the name of the environment variable (which must have a valid env var
key name: non-empty, no embedded NUL, no `=`).

The wasm start function is the function that determines the program's lifetime.
There are no exports other than the stdout stream export.

## Executable ABI

The Executable ABI is defined as the [Canonical ABI] bindings generated by wit-bindgen
for the Component ABI.

The wasm start function is not used (unless an instance-per-thread model is adopted, in which case it's just used to work around the memory-init problem). Instead, there is a dedicated export, to be defined by wit-bindgen,
which starts the main program. Probably "canonical_abi_start".

[Canonical ABI]: https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md

## External command-line interface

WASI commands and executables look to a Unix-style execution environment like programs that:
 - Return 0 or 1 on success or failure.
 - Can be passed normal command-line arguments
 - Can also be passed a sequence of environment variables. Implementations are encouraged to disallow programs from implicitly reading arbitrary environment variables.

Before each instance of the program, the WASI runtime first does the following:

- For each command-line argument and environment variable value:
   - A set of path strings is identified, as strings containing `/` in any of these
     positions:
       - as a suffix-after-a-'=',
       - as a prefix-before-a-`:` (if the original preopen string doesn't contain `:`),
       - as a suffix-after-a-`:` (if the original preopen string doesn't contain `:`), or
       - between-`:`s (if the original preopen string doesn't contain `:`)

   - For each path string, a preopen record (`struct Preopen` in the core-wasm ABI,
     `(string, handle preopen)` in the component ABI) is appended to the preopen list,
     containing:
      - A string consisting of a [version-4 UUID] in text format
      - A handle to a host resource representing the resource

   - The command-line argument or environment value is edited to replace the path
     strings with their corresponding UUID values.

Libc will then take the preopens, and make them available as virtual files and
directories named after their UUID strings.

[version-4 UUID]: https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)

## Stderr

It's [Stderr](Stderr.md) time.
